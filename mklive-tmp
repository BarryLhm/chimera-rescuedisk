
error_sig()
{
	[ -z "${2-}" ] || msg "error at line $2"
	[ "$DEBUG" != 1 ] || \
	{
		echo "Entering debug shell"
		"$DEBUG_SHELL"
	}
	exit "${1-0}"
}

trap 'error_sig "$?" "$LINENO"' INT

######################################## Packing image

## determine kernel version
for i in "${ROOT_DIR:?}/boot/"vmlinu[xz]-*
do	[ -f "$i" ] || break
	KERNVER=${i##*boot/}
	KERNVER=${KERNVER#*-}
	break
done

for i in "${ROOT_DIR:?}/boot/"vmlinu[xz]-*; do
	[ -f "$i" ] || break
	KERNFILE=${i##*boot/}
	KERNFILE=${KERNFILE%%-*}
	break
done

[ "$KERNVER" ] || die "live media require a kernel, but none detected"

[ "$KERNFILE" ] || die "no kernel found matching '${KERNVER}'"

# add live-boot initramfs stuff
msg "Copying live initramfs scripts..."

[ -x "${ROOT_DIR:?}/usr/bin/mkinitramfs" ] || \
 die "live media require initramfs-tools, but target root does not contain it"

copy_initramfs() {
	cp -R initramfs-tools/lib/live "${ROOT_DIR:?}/usr/lib" || return 1
	cp initramfs-tools/bin/* "${ROOT_DIR:?}/usr/bin" || return 1
	cp initramfs-tools/hooks/* "${ROOT_DIR:?}/usr/share/initramfs-tools/hooks" || return 1
	cp initramfs-tools/scripts/* "${ROOT_DIR:?}/usr/share/initramfs-tools/scripts" || return 1
	cp -R data "${ROOT_DIR:?}/lib/live"
}

cleanup_initramfs() {
	rm -rf "${ROOT_DIR:?}/usr/lib/live"
	cd "$WRKSRC/initramfs-tools/bin"
	for x in *; do
		rm -f "${ROOT_DIR:?}/usr/bin/$x"
	done
	cd "$WRKSRC/initramfs-tools/hooks"
	for x in *; do
		rm -f "${ROOT_DIR:?}/usr/share/initramfs-tools/hooks/$x"
	done
	cd "$WRKSRC/initramfs-tools/scripts"
	for x in *; do
		rm -f "${ROOT_DIR:?}/usr/share/initramfs-tools/scripts/$x"
	done
	cd "$WRKSRC"
}

copy_initramfs || die "failed to copy initramfs files"

# generate initramfs
msg "Generating initial ramdisk and copying kernel..."
chroot "${ROOT_DIR:?}" mkinitramfs -o /tmp/initrd "${KERNVER}" || die "unable to generate ramdisk"

mv "${ROOT_DIR:?}/tmp/initrd" "${LIVE_DIR:?}"

for i in "${ROOT_DIR:?}/boot/vmlinuz-${KERNVER}"; do
	cp "$i" "${LIVE_DIR:?}/vmlinuz"
done

# clean up target root
msg "Cleaning up target root..."

run_apk "${ROOT_DIR:?}" del chimerautils ${TARGET_PACKAGES}

cleanup_initramfs

cleanup_dirs() {
	for x in "$@"; do
		rm -rf "${ROOT_DIR:?}/${x}"
		mkdir -p "${ROOT_DIR:?}/${x}"
	done
}

cleanup_dirs run tmp root var/cache var/log var/tmp

chmod 777 "${ROOT_DIR:?}/tmp"
chmod 777 "${ROOT_DIR:?}/var/tmp"
chmod 750 "${ROOT_DIR:?}/root"

# clean up pointless ramdisk(s)
for f in "${ROOT_DIR:?}/boot/"initrd*; do
	[ -f "$f" ] && rm -f "$f"
done

# clean up backup shadow etc
rm -f "${ROOT_DIR:?}/etc/shadow-" "${ROOT_DIR:?}/etc/gshadow-" \
	 "${ROOT_DIR:?}/etc/passwd-" "${ROOT_DIR:?}/etc/group-" \
	 "${ROOT_DIR:?}/etc/subuid-" "${ROOT_DIR:?}/etc/subgid-"


# generate filesystem
msg "Generating root filesystem..."

mount --bind "${BUILD_DIR}" "${HOST_DIR:?}/mnt" || die "build dir bind mount failed"
[ "$USE_TMPFS" != "half" ] || mount --bind "${BUILD_DIR}/rootfs" "${HOST_DIR:?}/mnt/rootfs" || die "root dir bind mount failed"
[ "$USE_TMPFS" != "full" ] || \
{
	mount --bind "${BUILD_DIR}/rootfs" "${HOST_DIR:?}/mnt/rootfs" || die "root dir bind mount failed"
	mount --bind "${BUILD_DIR}/image" "${HOST_DIR:?}/mnt/image" || die "image dir bind mount failed"
}

case "$FSTYPE" in
	erofs)	# tried zstd, it's quite a bit bigger than xz... and experimental
		# when testing, level=3 is 1.9% bigger than 16 and 0.7% bigger than 9
		# ztailpacking has measurable space savings, fragments+dedupe does not
		chroot "${HOST_DIR:?}" /usr/bin/mkfs.erofs -b 4096 -z lzma -E ztailpacking \
		 /mnt/image/live/filesystem.erofs /mnt/rootfs || die "mkfs.erofs failed";;
	squashfs)	chroot "${HOST_DIR:?}" /usr/bin/gensquashfs --pack-dir /mnt/rootfs \
			 -c xz -k -x /mnt/image/live/filesystem.squashfs || die "gensquashfs failed";;
esac

# generate iso image
msg "Generating ISO image..."

generate_menu()
{
	sed \
	 -e "s|@@BOOT_TITLE@@|Chimera Maintenance Disk|g" \
	 -e "s|@@KERNFILE@@|$KERNFILE|g" \
	 -e "s|@@KERNVER@@|$KERNVER|g" \
	 -e "s|@@ARCH@@|$APK_ARCH|g" \
	 -e "s|@@BOOT_CMDLINE@@|$CMDLINE|g" \
	 "$1"
}

# grub support, mkrescue chooses what to do automatically

generate_iso_grub()
{
	# because host grub would not have all the targets
	chroot "${HOST_DIR:?}" /usr/bin/grub-mkrescue -o /mnt/image.iso \
	 --product-name "Chimera Maintenance Disk" \
	 --product-version "$(date "+%Y%m%d")" \
	 --mbr-force-bootable \
	 /mnt/image \
	 -volid "CHIMERA_LIVE"
}

# base args that will be present for any iso generation
generate_iso_base()
{
	chroot "${HOST_DIR:?}" /usr/bin/xorriso -as mkisofs -iso-level 3 \
	 -rock -joliet -max-iso9660-filenames -omit-period -omit-version-number \
	 -relaxed-filenames -allow-lowercase -volid CHIMERA_LIVE \
	 "$@" -o /mnt/image.iso /mnt/image
}

# maximally compatible setup for x86_64, one that can boot on bios machines
# as well as both mac efi and pc uefi, and from optical media as well as disk
generate_isohybrid_limine()
{
	generate_iso_base \
	 -eltorito-boot limine-bios-cd.bin -no-emul-boot -boot-load-size 4 \
	 -boot-info-table -hfsplus -apm-block-size 2048 -eltorito-alt-boot \
	 -e efi.img -efi-boot-part --efi-boot-image \
	 --protective-msdos-label --mbr-force-bootable
}

# just plain uefi support with nothing else, for non-x86 machines where there
# is no legacy to worry about, should still support optical media + disk
generate_efi_pure()
{
	generate_iso_base --efi-boot efi.img -efi-boot-part --efi-boot-image --protective-msdos-label
}

# ppc only, nyaboot + apm hybrid for legacy machines (mac, slof), modern
# machines do not care as long as it's mountable (and need no bootloader)
generate_ppc_nyaboot() {
	generate_iso_base \
	 -hfsplus -isohybrid-apm-hfsplus -hfsplus-file-creator-type chrp \
	 tbxi boot/ofboot.b -hfs-bless-by p boot -sysid PPC -chrp-boot-part
}

prepare_efi_img() {
	# make an efi image for eltorito (optical media boot)
	truncate -s 2949120 "${IMAGE_DIR}/efi.img" || die "failed to create EFI image"
	chroot "${HOST_DIR:?}" /usr/bin/mkfs.vfat -F12 -S 512 "/mnt/image/efi.img" > /dev/null \
	 || die "failed to format EFI image"
	LC_CTYPE=C chroot "${HOST_DIR:?}" /usr/bin/mmd -i "/mnt/image/efi.img" EFI EFI/BOOT \
	 || die "failed to populate EFI image"
	for img in "${IMAGE_DIR}/EFI/BOOT"/*; do
		img=${img##*/}
		LC_CTYPE=C chroot "${HOST_DIR:?}" /usr/bin/mcopy -i "/mnt/image/efi.img" \
		 "/mnt/image/EFI/BOOT/$img" "::EFI/BOOT/" || die "failed to populate EFI image"
	done
}

# grub.cfg for systems that parse this without invoking
# the actual bootloader, e.g. openpower systems and so on
mkdir -p "${IMAGE_DIR}/boot/grub"
generate_menu grub/menu.cfg.in > "${IMAGE_DIR}/boot/grub/grub.cfg"

	generate_menu limine/limine.conf.in > "${IMAGE_DIR}/limine.conf"
	# efi executables for usb/disk boot
	mkdir -p "${IMAGE_DIR}/EFI/BOOT"
	case "$APK_ARCH" in
	x86_64)	cp "${HOST_DIR:?}/usr/share/limine/BOOTIA32.EFI" "${IMAGE_DIR}/EFI/BOOT"
		cp "${HOST_DIR:?}/usr/share/limine/BOOTX64.EFI" "${IMAGE_DIR}/EFI/BOOT";;
	aarch64) cp "${HOST_DIR:?}/usr/share/limine/BOOTAA64.EFI" "${IMAGE_DIR}/EFI/BOOT";;
	riscv64) cp "${HOST_DIR:?}/usr/share/limine/BOOTRISCV64.EFI" "${IMAGE_DIR}/EFI/BOOT";;
	loongarch64)cp "${HOST_DIR:?}/usr/share/limine/BOOTLOONGARCH64.EFI" "${IMAGE_DIR}/EFI/BOOT";;
	*) die "Unknown architecture $APK_ARCH for EFI";;
	esac
	# make an efi image for eltorito (optical media boot)
	prepare_efi_img
	# now generate
	case "$APK_ARCH" in
	x86_64)	# but first, necessary extra files for bios
		cp "${HOST_DIR:?}/usr/share/limine/limine-bios-cd.bin" "${IMAGE_DIR}"
		cp "${HOST_DIR:?}/usr/share/limine/limine-bios.sys" "${IMAGE_DIR}"
		# generate image
		generate_isohybrid_limine || die "failed to generate ISO image"
		# and install bios
		chroot "${HOST_DIR:?}" /usr/bin/limine bios-install "/mnt/image.iso";;
	aarch64|loongarch64|riscv64) generate_efi_pure || die "failed to generate ISO image";;
	*) die "Unknown architecture $APK_ARCH for limine";;
	esac;;

mv "$BUILD_DIR/image.iso" "$OUT_FILE"

msg "Successfully generated image '$OUT_FILE'"
